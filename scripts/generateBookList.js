import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

async function generateBookList() {
  const pdfsDir = path.join(__dirname, '../pdfs');
  const imagesDir = path.join(__dirname, '../images');

  try {
    // Read directories
    const [pdfs, images] = await Promise.all([
      fs.readdir(pdfsDir),
      fs.readdir(imagesDir)
    ]);

    // Filter PDFs and images
    const pdfFiles = pdfs.filter(file => file.toLowerCase().endsWith('.pdf'));
    const imageFiles = images.filter(file => 
      file.toLowerCase().endsWith('.png') || 
      file.toLowerCase().endsWith('.jpg') || 
      file.toLowerCase().endsWith('.jpeg')
    );

    // Generate book list
    const books = pdfFiles.map((pdf, index) => {
      const baseName = pdf.replace('.pdf', '').toLowerCase();
      const thumbnail = imageFiles.find(img => 
        img.toLowerCase().replace(/\.[^/.]+$/, '').includes(baseName) ||
        baseName.includes(img.toLowerCase().replace(/\.[^/.]+$/, ''))
      );

      // Extract author from filename if it contains "by"
      const authorMatch = pdf.match(/by\s+([^\.]+)/i);
      const author = authorMatch ? authorMatch[1].trim() : 'Unknown';

      // Determine category based on filename
      const lowerTitle = pdf.toLowerCase();
      let category = 'other';
      
      if (/python|programming|code|javascript|java|ruby|cpp|csharp/.test(lowerTitle)) {
        category = 'programming';
      } else if (/hack|security|penetration|exploit|cyber|ceh/.test(lowerTitle)) {
        category = 'security';
      } else if (/network|cisco|protocol|routing/.test(lowerTitle)) {
        category = 'networking';
      } else if (/hardware|device|mobile|android|ios/.test(lowerTitle)) {
        category = 'hardware';
      }

      return {
        id: String(index + 1),
        title: pdf.replace('.pdf', ''),
        path: `/Book-Wurm/pdfs/${pdf}`,
        thumbnail: thumbnail ? `/Book-Wurm/images/${thumbnail}` : null,
        author,
        category,
        pageCount: 0
      };
    });

    // Write to fileSystem.ts
    const fileContent = `import { FileSystemBook } from '../types';

// This list is auto-generated by scripts/generateBookList.js
export const BOOKS: FileSystemBook[] = ${JSON.stringify(books, null, 2)};

export async function scanBooks(): Promise<FileSystemBook[]> {
  try {
    // For GitHub Pages, we'll use the static list
    if (window.location.hostname.includes('github.io')) {
      return BOOKS;
    }

    // For local development, fetch from API
    const response = await fetch('/api/books');
    if (!response.ok) {
      throw new Error('Failed to fetch books');
    }
    const books = await response.json();
    
    // Transform paths for local development
    return books.map((book: FileSystemBook) => ({
      ...book,
      path: book.path.replace('/Book-Wurm/', '/'),
      thumbnail: book.thumbnail ? book.thumbnail.replace('/Book-Wurm/', '/') : null
    }));
  } catch (error) {
    console.error('Error scanning books:', error);
    return BOOKS; // Fallback to static list
  }
}

export type { FileSystemBook };`;

    await fs.writeFile(
      path.join(__dirname, '../src/utils/fileSystem.ts'),
      fileContent,
      'utf-8'
    );

    console.log(`Generated book list with ${books.length} books`);
  } catch (error) {
    console.error('Error generating book list:', error);
    process.exit(1);
  }
}

generateBookList();