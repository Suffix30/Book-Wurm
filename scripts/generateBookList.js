import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));

function normalizeFilename(filename) {
  return filename
    .replace(/\.[^/.]+$/, '')
    .toLowerCase()
    .replace(/[^a-z0-9\s]/g, ' ')
    .replace(/\s+/g, ' ')
    .replace(/handbook|edition|volume|vol|part|by|and|the|discovering|exploiting|security|holes/g, '')
    .trim();
}

function findMatchingImage(pdfName, images) {
  const normalizedPdf = normalizeFilename(pdfName);
  const pdfWords = normalizedPdf
    .split(' ')
    .filter(word => word.length > 2);
  
  const scoredImages = images.map(img => {
    const normalizedImg = normalizeFilename(img);
    const imgWords = normalizedImg
      .split(' ')
      .filter(word => word.length > 2);
    
    let score = 0;
    
    pdfWords.forEach(pdfWord => {
      if (imgWords.includes(pdfWord)) {
        score += 3;
      } else {
        imgWords.forEach(imgWord => {
          if (pdfWord.includes(imgWord) || imgWord.includes(pdfWord)) {
            score += 1;
          }
        });
      }
    });

    if (normalizedImg === normalizedPdf) {
      score += 5;
    }
    
    return {
      image: img,
      score,
      normalizedImg
    };
  });

  const bestMatch = scoredImages.sort((a, b) => {
    if (b.score === a.score) {
      return a.normalizedImg.length - b.normalizedImg.length;
    }
    return b.score - a.score;
  })[0];
  
  return bestMatch && bestMatch.score >= 2 ? bestMatch.image : null;
}

async function generateBookList() {
  const pdfsDir = path.join(__dirname, '../pdfs');
  const imagesDir = path.join(__dirname, '../images');

  try {
    const [pdfs, images] = await Promise.all([
      fs.readdir(pdfsDir),
      fs.readdir(imagesDir)
    ]);

    const pdfFiles = pdfs.filter(file => file.toLowerCase().endsWith('.pdf'));
    const imageFiles = images.filter(file => 
      file.toLowerCase().endsWith('.png') || 
      file.toLowerCase().endsWith('.jpg') || 
      file.toLowerCase().endsWith('.jpeg')
    );

    const books = pdfFiles.map((pdf, index) => {
      const thumbnail = findMatchingImage(pdf, imageFiles);
      const authorMatch = pdf.match(/by\s+([^\.]+)/i);
      const author = authorMatch ? authorMatch[1].trim() : 'Unknown';
      const lowerTitle = pdf.toLowerCase();
      
      let category = 'other';
      if (/python|programming|code|javascript|java|ruby|cpp|csharp/.test(lowerTitle)) {
        category = 'programming';
      } else if (/hack|security|penetration|exploit|cyber|ceh/.test(lowerTitle)) {
        category = 'security';
      } else if (/network|cisco|protocol|routing/.test(lowerTitle)) {
        category = 'networking';
      } else if (/hardware|device|mobile|android|ios/.test(lowerTitle)) {
        category = 'hardware';
      }

      console.log(`Matching PDF: ${pdf}`);
      console.log(`Found thumbnail: ${thumbnail || 'None'}`);

      return {
        id: String(index + 1),
        title: pdf.replace('.pdf', ''),
        path: `/Book-Wurm/pdfs/${pdf}`,
        thumbnail: thumbnail ? `/Book-Wurm/images/${thumbnail}` : null,
        author,
        category,
        pageCount: 0
      };
    });

    const fileContent = `import { FileSystemBook } from '../types';

// This list is auto-generated by scripts/generateBookList.js
export const BOOKS: FileSystemBook[] = ${JSON.stringify(books, null, 2)};

export async function scanBooks(): Promise<FileSystemBook[]> {
  try {
    // For GitHub Pages, we'll use the static list
    if (window.location.hostname.includes('github.io')) {
      return BOOKS;
    }

    // For local development, fetch from API
    const response = await fetch('/api/books');
    if (!response.ok) {
      throw new Error('Failed to fetch books');
    }
    const books = await response.json() as FileSystemBook[];
    
    // Transform paths for local development
    return books.map((book: FileSystemBook) => ({
      ...book,
      path: book.path.replace('/Book-Wurm/', '/'),
      thumbnail: book.thumbnail ? book.thumbnail.replace('/Book-Wurm/', '/') : null
    }));
  } catch (error) {
    console.error('Error scanning books:', error);
    return BOOKS; // Fallback to static list
  }
}

export type { FileSystemBook };`;

    await fs.writeFile(
      path.join(__dirname, '../src/utils/fileSystem.ts'),
      fileContent,
      'utf-8'
    );

    console.log(`Generated book list with ${books.length} books`);
  } catch (error) {
    console.error('Error generating book list:', error);
    process.exit(1);
  }
}

generateBookList();